enclave {
    include "tss2/tpm20.h"

    struct sized_buf {
        size_t size;
        uint8_t *buf;
    };

    trusted {
        public int tss2_tcti_sgx_init_ecall (void);
        public int tss2_tcti_sgx_finalize_ecall (void);
    };

    untrusted {
        /* It's possible for the enclave to have multiple threads / TCTIs. The
         * hosting application may need to have some sort of in-process
         * resource manager eventually. For now we assign the TCTI a session
         * identifier when intialized.
         */
        uint64_t
        tss2_tcti_sgx_init_ocall       (void);
        TSS2_RC
        tss2_tcti_sgx_transmit_ocall   (uint64_t   session_id,
                                        [in, sizefunc=sizeof_sized_buf] const sized_buf *buf);
        TSS2_RC
        tss2_tcti_sgx_receive_ocall    (uint64_t  session_id,
                                        [in, out, sizefunc=sizeof_sized_buf] sized_buf *buf,
                                        uint32_t  timeout);
        void
        tss2_tcti_sgx_finalize_ocall   (uint64_t  session_id);
        TSS2_RC
        tss2_tcti_sgx_cancel_ocall     (uint64_t  session_id);
        /* Not sure the getPollHandles functions makes much sense here.
        TSS2_RC
        tss2_tcti_sgx_get_poll_handles (uint64_t  session_id,
                                        [out] TSS2_TCTI_POLL_HANDLE *handles,
                                        [out] size_t    *num_handles);
        TSS2_RC
        tss2_tcti_sgx_set_locality     (uint64_t  session_id,
                                        uint8_t   locality);
        */
   };
};
